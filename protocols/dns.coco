version 1.0
endian be

// ============================================================================
// DNS Protocol (RFC 1035)
// ============================================================================
// Full DNS support with label compression, variable-length arrays, and
// terminator-based sizing. All features now working!

// DNS OpCodes (RFC 1035)
enum DnsOpCode : u8 {
  QUERY = 0,
  IQUERY = 1,
  STATUS = 2
}

// DNS Response Codes (RFC 1035)
enum DnsRCode : u8 {
  NO_ERROR = 0,
  FORMAT_ERROR = 1,
  SERVER_FAILURE = 2,
  NAME_ERROR = 3,
  NOT_IMPLEMENTED = 4,
  REFUSED = 5
}

// DNS Question Types (RFC 1035 and extensions)
enum DnsQType : u16 {
  A = 1,
  NS = 2,
  CNAME = 5,
  SOA = 6,
  PTR = 12,
  MX = 15,
  TXT = 16,
  AAAA = 28,
  SRV = 33,
  ANY = 255
}

// DNS Question Classes (RFC 1035)
enum DnsQClass : u16 {
  IN = 1,
  CS = 2,
  CH = 3,
  HS = 4,
  ANY = 255
}

// DNS header (12 bytes fixed)
message dns_header {
  u16 transaction_id
  bits[16] flags {
    bit qr_response     // 0=query, 1=response (MSB)
    bits[4] opcode
    bit authoritative
    bit truncated
    bit recursion_desired
    bit recursion_available
    bits[3] z_reserved
    bits[4] rcode       // RCODE (LSB)
  }
  u16 question_count
  u16 answer_count
  u16 authority_count
  u16 additional_count
}

// DNS name
// A DNS name can be:
// 1. A compression pointer (c0 xx) - 2 bytes total, jumps to another location
// 2. A label sequence ending with 0x00 terminator
message dns_name {
  bits[2] label_type
  match label_type {
    0b11 -> {
      // Compression pointer: 14 bits of offset remaining
      bits[14] pointer_offset [offset_of: dns_name]
    }
    0b00 -> {
      // Normal label or terminator: 6 bits of length remaining
      bits[6] label_length
      match label_length {
        0 -> {} // Terminator - name ends here
        _ -> {
          // Label with data followed by next name part
          bytes label_data[label_length]
          dns_name next
        }
      }
    }
  }
}

// DNS question section entry
// Domain name is a sequence of labels ending with 0x00 terminator
// Example: "google.com" = 06 67 6f 6f 67 6c 65 03 63 6f 6d 00
message dns_question {
  dns_name qname [display: dnsname]
  DnsQType qtype
  DnsQClass qclass
}

// DNS resource record (answer, authority, additional)
// Name can be either a label sequence OR a compression pointer
message dns_rr {
  dns_name name [display: dnsname]             // Handles both pointer and normal names
  DnsQType rr_type
  DnsQClass rr_class
  u32 ttl
  u16 rd_length
  bytes rdata[rd_length] match rr_type {
    DnsQType.A -> {
      u32 address4 [display: ipv4]
    }
    DnsQType.AAAA -> {
      bytes address6[16] [display: ipv6]
    }
    DnsQType.MX -> {
      u16 preference
      dns_name exchange [display: dnsname]
    }
    DnsQType.CNAME -> {
      dns_name cname [display: dnsname]
    }
    DnsQType.NS -> {
      dns_name nsname [display: dnsname]
    }
    DnsQType.PTR -> {
      dns_name ptrname [display: dnsname]
    }
    _ -> {}
  }
}

// Complete DNS message (query or response)
layer message dns_message {
  dns_header header
  dns_question questions[header.question_count]   // Variable-length array
  dns_rr answers[header.answer_count]             // Variable-length array
  dns_rr authority[header.authority_count]        // Variable-length array
  dns_rr additional[header.additional_count]      // Variable-length array
}
