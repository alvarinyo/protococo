version 1.0
endian be

// ============================================================================
// DNS (RFC 1035)
// ============================================================================

// DNS OpCodes (RFC 1035)
enum DnsOpCode : u8 {
  QUERY = 0,
  IQUERY = 1,
  STATUS = 2
}

// DNS Response Codes (RFC 1035)
enum DnsRCode : u8 {
  NO_ERROR = 0,
  FORMAT_ERROR = 1,
  SERVER_FAILURE = 2,
  NAME_ERROR = 3,
  NOT_IMPLEMENTED = 4,
  REFUSED = 5
}

// DNS Question Types (RFC 1035 and extensions)
enum DnsQType : u16 {
  A = 1,
  NS = 2,
  CNAME = 5,
  SOA = 6,
  PTR = 12,
  MX = 15,
  TXT = 16,
  AAAA = 28,
  SRV = 33,
  ANY = 255
}

// DNS Question Classes (RFC 1035)
enum DnsQClass : u16 {
  IN = 1,
  CS = 2,
  CH = 3,
  HS = 4,
  ANY = 255
}

// DNS header (12 bytes)
message dns_header {
  u16 transaction_id
  bits[16] flags {
    bit rcode3          // RCODE bit 3
    bit rcode2          // RCODE bit 2
    bit rcode1          // RCODE bit 1
    bit rcode0          // RCODE bit 0
    bit checking_disabled
    bit authenticated_data
    bit z_reserved
    bit recursion_available
    bit recursion_desired
    bit truncated
    bit authoritative
    bit opcode3         // OPCODE bit 3
    bit opcode2         // OPCODE bit 2
    bit opcode1         // OPCODE bit 1
    bit opcode0         // OPCODE bit 0
    bit qr_response     // 0=query, 1=response
  }
  u16 question_count
  u16 answer_count
  u16 authority_count
  u16 additional_count
}

// DNS label (length-prefixed string, part of domain name encoding)
// DNS names are sequences of labels ending with 0x00
// e.g., "www.example.com" = 03 77 77 77 07 65 78 61 6d 70 6c 65 03 63 6f 6d 00
message dns_label {
  u8 length
  bytes label[length]
}

// DNS question section entry
// NOTE: This message cannot be correctly specified in current protococo syntax!
//
// Problem: DNS domain names are self-describing (length-prefixed labels ending
// with 0x00), but we can't express "variable-length field followed by fixed fields".
// Using qname[...] would consume ALL remaining bytes, leaving nothing for qtype/qclass.
//
// What's needed: Syntax like [until: 0x00] or self-describing label sequences.
// Example domain "google.com" = 06 67 6f 6f 67 6c 65 03 63 6f 6d 00
//
// message dns_question {
//   dns_label_sequence qname  // Hypothetical: repeats dns_label until 0x00
//   DnsQType qtype
//   DnsQClass qclass
// }

// Base DNS resource record (common fields)
// NOTE: Also has the same limitation as dns_question!
// The name[...] field would consume all bytes, leaving nothing for the remaining fields.
//
// message dns_rr {
//   dns_label_sequence name  // Hypothetical syntax
//   DnsQType rr_type
//   DnsQClass rr_class
//   u32 ttl
//   u16 rd_length
//   bytes rdata[rd_length]
// }

// DNS resource record subtypes
// NOTE: All commented out because dns_rr base message is not specifiable
//
// message dns_rr_a extends dns_rr {
//   rr_type = DnsQType.A
//   rd_length = 4
//   rdata {
//     u32 address [display: ipv4]
//   }
// }
//
// message dns_rr_aaaa extends dns_rr {
//   rr_type = DnsQType.AAAA
//   rd_length = 16
//   rdata {
//     bytes address[16] [display: ipv6]
//   }
// }
//
// (Additional DNS RR types omitted - all have same limitation)

// Complete DNS message (query or response)
layer message dns_message {
  dns_header header
  // Note: Full question/answer parsing would require dynamic arrays
  // For now, this provides the header structure and can be extended
  // with specific question/answer parsing based on counts
  bytes questions[...]   // question_count questions (variable length)
  // bytes answers[...]     // answer_count answers (variable length)
  // bytes authority[...]   // authority_count authority RRs (variable length)
  // bytes additional[...]  // additional_count additional RRs (variable length)
}
