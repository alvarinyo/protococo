version 1.0
endian be

// All fields are big-endian (network byte order)

// ============================================================================
// Enums
// ============================================================================

// IP Protocol/Next Header numbers (shared by IPv4 and IPv6)
enum Protocol : u8 {
  ICMP = 1,
  TCP = 6,
  UDP = 17,
  ICMPV6 = 58
}

// ICMP message types
enum IcmpType : u8 {
  ECHO_REPLY = 0,
  DEST_UNREACHABLE = 3,
  SOURCE_QUENCH = 4,
  REDIRECT = 5,
  ECHO_REQUEST = 8,
  TIME_EXCEEDED = 11,
  PARAMETER_PROBLEM = 12,
  TIMESTAMP_REQUEST = 13,
  TIMESTAMP_REPLY = 14
}

// TCP flags are defined inline as a bits field in tcp_segment

// EtherType values (IEEE 802.3)
enum EtherType : u16 {
  IPV4 = 0x0800,
  ARP = 0x0806,
  VLAN = 0x8100,
  IPV6 = 0x86DD
}

// ARP operation codes
enum ArpOp : u16 {
  REQUEST = 1,
  REPLY = 2
}

// TCP option kinds (RFC 793, 1323, 2018, 7323)
enum TcpOptKind : u8 {
  END = 0,
  NOP = 1,
  MSS = 2,
  WINDOW_SCALE = 3,
  SACK_PERMITTED = 4,
  SACK = 5,
  TIMESTAMPS = 8
}

// DNS OpCodes (RFC 1035)
enum DnsOpCode : u8 {
  QUERY = 0,
  IQUERY = 1,
  STATUS = 2
}

// DNS Response Codes (RFC 1035)
enum DnsRCode : u8 {
  NO_ERROR = 0,
  FORMAT_ERROR = 1,
  SERVER_FAILURE = 2,
  NAME_ERROR = 3,
  NOT_IMPLEMENTED = 4,
  REFUSED = 5
}

// DNS Question Types (RFC 1035 and extensions)
enum DnsQType : u16 {
  A = 1,
  NS = 2,
  CNAME = 5,
  SOA = 6,
  PTR = 12,
  MX = 15,
  TXT = 16,
  AAAA = 28,
  SRV = 33,
  ANY = 255
}

// DNS Question Classes (RFC 1035)
enum DnsQClass : u16 {
  IN = 1,
  CS = 2,
  CH = 3,
  HS = 4,
  ANY = 255
}

// ============================================================================
// Transport Layer Protocols (reusable)
// ============================================================================

// TCP option using match with [] for branch-determined size
// Each branch has different structure and size - replaces inheritance
message tcp_option {
  TcpOptKind kind
  bytes rest[] match kind {
    TcpOptKind.NOP -> {}           // 0 bytes - total option is 1 byte
    TcpOptKind.END -> {}           // 0 bytes - total option is 1 byte
    TcpOptKind.MSS -> {
      u8 length = 0x04
      u16 mss
    }
    TcpOptKind.WINDOW_SCALE -> {
      u8 length = 0x03
      u8 shift_count
    }
    TcpOptKind.SACK_PERMITTED -> {
      u8 length = 0x02
    }
    TcpOptKind.TIMESTAMPS -> {
      u8 length = 0x0A
      u32 ts_val
      u32 ts_ecr
    }
    _ -> {
      // Unknown option - uses size-from-match for data
      u8 length
      bytes data[length - 2]
    }
  }
}

// TCP segment (RFC 793)
// Bytes 12-13 contain data_offset (4b) + reserved (4b) + flags (8b) = 16 bits
layer message tcp_segment {
  u16 src_port [display: port]
  u16 dst_port [display: port]
  u32 seq_num
  u32 ack_num
  bits[16] data_offset_flags {
    // Flags (low 8 bits) - bit 0 is fin, bit 7 is cwr
    bit fin
    bit syn
    bit rst
    bit psh
    bit ack
    bit urg
    bit ece
    bit cwr
    // Reserved and data offset (high 8 bits)
    bits[4] reserved
    bits[4] data_offset
  }
  u16 window
  u16 checksum
  u16 urgent_ptr
  // Options parsed as polymorphic array - tries all tcp_option subtypes
  tcp_option options[data_offset_flags.data_offset * 4 - 20]
  bytes data[...]  // Payload - greedy, consumes remaining from upper layer
}

// UDP datagram (RFC 768)
layer message udp_datagram {
  u16 src_port [display: port]
  u16 dst_port [display: port]
  u16 length
  u16 checksum
  bytes data[length - 8] match dst_port {
    53 -> dns_message dns
    _ -> {}
  }
}

// ============================================================================
// DNS (RFC 1035)
// ============================================================================

// DNS header (12 bytes)
message dns_header {
  u16 transaction_id
  bits[16] flags {
    bit rcode3          // RCODE bit 3
    bit rcode2          // RCODE bit 2
    bit rcode1          // RCODE bit 1
    bit rcode0          // RCODE bit 0
    bit checking_disabled
    bit authenticated_data
    bit z_reserved
    bit recursion_available
    bit recursion_desired
    bit truncated
    bit authoritative
    bit opcode3         // OPCODE bit 3
    bit opcode2         // OPCODE bit 2
    bit opcode1         // OPCODE bit 1
    bit opcode0         // OPCODE bit 0
    bit qr_response     // 0=query, 1=response
  }
  u16 question_count
  u16 answer_count
  u16 authority_count
  u16 additional_count
}

// DNS label (length-prefixed string, part of domain name encoding)
// DNS names are sequences of labels ending with 0x00
// e.g., "www.example.com" = 03 77 77 77 07 65 78 61 6d 70 6c 65 03 63 6f 6d 00
message dns_label {
  u8 length
  bytes label[length]
}

// DNS question section entry
message dns_question {
  // QNAME: sequence of labels (variable length, ends with 0x00)
  // Note: This simplified version doesn't handle label compression (pointers)
  bytes qname[...]       // Domain name as label sequence (greedy)
  DnsQType qtype
  DnsQClass qclass
}

// Base DNS resource record (common fields)
message dns_rr {
  bytes name[...]        // Domain name (may use compression pointers) (greedy)
  DnsQType rr_type
  DnsQClass rr_class
  u32 ttl
  u16 rd_length
  bytes rdata[rd_length]
}

// DNS A record (IPv4 address)
message dns_rr_a extends dns_rr {
  rr_type = DnsQType.A
  rd_length = 4
  rdata {
    u32 address [display: ipv4]
  }
}

// DNS AAAA record (IPv6 address)
message dns_rr_aaaa extends dns_rr {
  rr_type = DnsQType.AAAA
  rd_length = 16
  rdata {
    bytes address[16] [display: ipv6]
  }
}

// DNS CNAME record (canonical name)
message dns_rr_cname extends dns_rr {
  rr_type = DnsQType.CNAME
  rdata {
    bytes cname[...]     // Domain name (greedy)
  }
}

// DNS NS record (name server)
message dns_rr_ns extends dns_rr {
  rr_type = DnsQType.NS
  rdata {
    bytes nsdname[...]   // Name server domain name (greedy)
  }
}

// DNS MX record (mail exchange)
message dns_rr_mx extends dns_rr {
  rr_type = DnsQType.MX
  rdata {
    u16 preference
    bytes exchange[...]  // Mail exchange domain name (greedy)
  }
}

// DNS PTR record (pointer)
message dns_rr_ptr extends dns_rr {
  rr_type = DnsQType.PTR
  rdata {
    bytes ptrdname[...]  // Pointer domain name (greedy)
  }
}

// DNS TXT record (text strings)
message dns_rr_txt extends dns_rr {
  rr_type = DnsQType.TXT
  rdata {
    bytes txt_data[...]  // One or more character strings (greedy)
  }
}

// Complete DNS message (query or response)
layer message dns_message {
  dns_header header
  // Note: Full question/answer parsing would require dynamic arrays
  // For now, this provides the header structure and can be extended
  // with specific question/answer parsing based on counts
  bytes questions[...]   // question_count questions (greedy)
  // bytes answers[...]     // answer_count answers (greedy)
  // bytes authority[...]   // authority_count authority RRs (greedy)
  // bytes additional[...]  // additional_count additional RRs (greedy)
}

// ICMP message (RFC 792)
layer message icmp_message {
  IcmpType icmp_type
  u8 code
  u16 checksum
  u16 identifier
  u16 sequence
  bytes data[...]        // Payload (greedy)
}

// ============================================================================
// ARP (RFC 826)
// ============================================================================

// ARP packet for IPv4 over Ethernet
layer message arp_packet {
  u16 hw_type           // 1 = Ethernet
  u16 proto_type        // 0x0800 = IPv4
  u8 hw_len             // 6 for Ethernet
  u8 proto_len          // 4 for IPv4
  ArpOp operation
  bytes sender_mac[6] [display: mac]
  u32 sender_ip [display: ipv4]
  bytes target_mac[6] [display: mac]
  u32 target_ip [display: ipv4]
}

// ============================================================================
// IPv4 (RFC 791)
// ============================================================================

// IPv4 header (20 bytes minimum, no options)
message ipv4_header {
  bits[8] version_ihl {
    bits[4] ihl
    bits[4] version
  }
  u8 dscp_ecn
  u16 total_length
  u16 identification
  bits[16] flags_fragment {
    bits[13] fragment_offset
    bit more_fragments      // MF flag
    bit dont_fragment       // DF flag
    bit reserved
  }
  u8 ttl
  Protocol protocol
  u16 header_checksum
  u32 src_ip [display: ipv4]
  u32 dst_ip [display: ipv4]
}

// IPv4 packet with polymorphic payload based on protocol field
layer message ipv4_packet {
  ipv4_header header
  bytes payload[header.total_length - 20] match header.protocol {
    Protocol.TCP -> tcp_segment tcp
    Protocol.UDP -> udp_datagram udp
    Protocol.ICMP -> icmp_message icmp
    _ -> {}
  }
}

// ============================================================================
// IPv6 (RFC 8200)
// ============================================================================

// IPv6 header (40 bytes fixed, no options in base header)
message ipv6_header {
  bits[32] version_tc_flow {
    bits[20] flow_label
    bits[8] traffic_class
    bits[4] version           // Always 6
  }
  u16 payload_length
  Protocol next_header        // Same as IPv4 protocol field
  u8 hop_limit
  bytes src_ip[16] [display: ipv6]
  bytes dst_ip[16] [display: ipv6]
}

// IPv6 packet with polymorphic payload based on next_header field
layer message ipv6_packet {
  ipv6_header header
  bytes payload[header.payload_length] match header.next_header {
    Protocol.TCP -> tcp_segment tcp
    Protocol.UDP -> udp_datagram udp
    Protocol.ICMPV6 -> icmp_message icmpv6
    _ -> {}
  }
}

// ============================================================================
// Ethernet (IEEE 802.3)
// ============================================================================

// Ethernet header (14 bytes)
message ethernet_header {
  bytes dst_mac[6] [display: mac]
  bytes src_mac[6] [display: mac]
  EtherType ethertype
}

// 802.1Q VLAN frame (tag + inner payload)
layer message vlan_frame {
  bits[16] tci {
    bits[12] vlan_id
    bit dei               // Drop Eligible Indicator
    bits[3] pcp           // Priority Code Point
  }
  EtherType inner_ethertype
  bytes inner[] match inner_ethertype {
    EtherType.IPV4 -> ipv4_packet ip
    EtherType.IPV6 -> ipv6_packet ip6
    EtherType.ARP -> arp_packet arp
    _ -> {}
  }
}

// Ethernet frame with polymorphic payload based on ethertype
layer message ethernet_frame {
  ethernet_header eth
  bytes payload[] match eth.ethertype {
    EtherType.IPV4 -> ipv4_packet ip
    EtherType.IPV6 -> ipv6_packet ip6
    EtherType.ARP -> arp_packet arp
    EtherType.VLAN -> vlan_frame vlan
    _ -> {}
  }
}
