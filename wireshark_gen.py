"""
Protococo Wireshark Lua Dissector Generator

Generates Wireshark Lua dissector code from .coco protocol definitions.
"""

from coco_ast import (
    CocoFile, Message, Field, EnumDef,
    IntegerType, BytesType, StringType, PadType, BitFieldType, EnumTypeRef,
    LiteralSize, FieldRefSize, VariableSize, SizeExpr,
    MatchClause, EnumValue,
)


def generate_lua_dissector(coco_file: CocoFile, message_name: str = None) -> str:
    """Generate Wireshark Lua dissector code from a CocoFile.

    Args:
        coco_file: Parsed .coco file
        message_name: Optional specific message to generate (default: all top-level)

    Returns:
        Lua dissector code as string
    """
    gen = LuaGenerator(coco_file)
    return gen.generate(message_name)


class LuaGenerator:
    """Generates Wireshark Lua dissector code."""

    def __init__(self, coco_file: CocoFile):
        self.coco = coco_file
        self.indent = 0
        self.lines = []
        self.proto_fields = []
        self.generated_fields = set()  # Track generated field var names

    def generate(self, message_name: str = None) -> str:
        """Generate complete Lua dissector."""
        self.lines = []
        self.proto_fields = []
        self.generated_fields = set()

        # Header comment
        self._emit("-- Wireshark Lua Dissector")
        self._emit("-- Generated by protococo from .coco file")
        self._emit("")

        # Determine which messages to generate
        if message_name:
            messages = [self.coco.get_message(message_name)]
            if not messages[0]:
                raise ValueError(f"Message '{message_name}' not found")
        else:
            # Generate for top-level messages (no parent)
            messages = [m for m in self.coco.messages if not m.parent]

        # Generate enum value tables
        for enum in self.coco.enums:
            self._generate_enum_table(enum)

        self._emit("")

        # Generate protocol and fields for each message
        for msg in messages:
            self._generate_protocol(msg)
            self._emit("")

        return "\n".join(self.lines)

    def _emit(self, line: str = ""):
        """Emit a line of code."""
        if line:
            self.lines.append("    " * self.indent + line)
        else:
            self.lines.append("")

    def _generate_enum_table(self, enum: EnumDef):
        """Generate Lua table for enum values."""
        self._emit(f"local {enum.name}_values = {{")
        self.indent += 1
        for member in enum.members:
            self._emit(f"[{member.value}] = \"{member.name}\",")
        self.indent -= 1
        self._emit("}")

    def _generate_protocol(self, msg: Message):
        """Generate protocol definition for a message."""
        proto_name = msg.name
        proto_var = f"{proto_name}_proto"

        # Create protocol
        self._emit(f"-- Protocol: {msg.name}")
        self._emit(f"local {proto_var} = Proto(\"{proto_name}\", \"{proto_name.replace('_', ' ').title()}\")")
        self._emit("")

        # Collect all ProtoFields recursively
        self._emit("-- Fields")
        fields = self._resolve_fields(msg)
        self._collect_proto_fields(proto_name, fields, "")

        # Emit unique field definitions
        for pf in self.proto_fields:
            if pf['var_name'] not in self.generated_fields:
                self._emit(pf['definition'])
                self.generated_fields.add(pf['var_name'])

        self._emit("")

        # Assign fields to protocol
        field_names = [f['var_name'] for f in self.proto_fields if not f.get('skip_registration')]
        if field_names:
            # Chunk into lines of reasonable length
            self._emit(f"{proto_var}.fields = {{")
            self.indent += 1
            for name in field_names:
                self._emit(f"{name},")
            self.indent -= 1
            self._emit("}")
        self._emit("")

        # Generate dissector function
        self._generate_dissector(msg, proto_var)

        # Register with ethertype or other table if applicable
        self._generate_registration(msg, proto_var)

    def _resolve_fields(self, msg: Message) -> list[Field]:
        """Get all fields for a message, including inherited."""
        fields = []
        if msg.parent:
            parent = self.coco.get_message(msg.parent)
            if parent:
                fields.extend(self._resolve_fields(parent))
        fields.extend(msg.fields)
        return fields

    def _collect_proto_fields(self, proto_name: str, fields: list[Field], prefix: str):
        """Recursively collect all ProtoField definitions."""
        for field in fields:
            self._collect_field_proto_fields(proto_name, field, prefix)

    def _collect_field_proto_fields(self, proto_name: str, field: Field, prefix: str):
        """Collect ProtoField definitions for a single field."""
        field_path = f"{prefix}{field.name}" if prefix else field.name
        var_name = f"f_{proto_name}_{field_path}".replace(".", "_")
        field_type = field.type

        if isinstance(field_type, IntegerType):
            lua_type, base = self._int_type_to_lua(field_type, field)
            self.proto_fields.append({
                'var_name': var_name,
                'field_name': field.name,
                'field_path': field_path,
                'definition': f"local {var_name} = {lua_type}(\"{proto_name}.{field_path}\", \"{field.name}\", {base})",
                'size': field_type.byte_size,
                'lua_type': lua_type,
                'type': 'int',
            })

        elif isinstance(field_type, BytesType):
            self.proto_fields.append({
                'var_name': var_name,
                'field_name': field.name,
                'field_path': field_path,
                'definition': f"local {var_name} = ProtoField.bytes(\"{proto_name}.{field_path}\", \"{field.name}\")",
                'size': field.size,
                'type': 'bytes',
                'match_clause': field.match_clause,
                'structure_body': field.structure_body,
            })
            # Collect fields from match branches
            if field.match_clause:
                for branch in field.match_clause.branches:
                    if branch.fields:
                        self._collect_proto_fields(proto_name, branch.fields, f"{field_path}.")
            # Collect fields from structure body
            if field.structure_body:
                self._collect_proto_fields(proto_name, field.structure_body, f"{field_path}.")

        elif isinstance(field_type, StringType):
            self.proto_fields.append({
                'var_name': var_name,
                'field_name': field.name,
                'field_path': field_path,
                'definition': f"local {var_name} = ProtoField.string(\"{proto_name}.{field_path}\", \"{field.name}\")",
                'size': field.size,
                'type': 'string',
            })

        elif isinstance(field_type, BitFieldType):
            if field.bitfield_body:
                for bf in field.bitfield_body.fields:
                    bf_var = f"f_{proto_name}_{field_path}_{bf.name}".replace(".", "_")
                    mask = self._calculate_bitmask(field.bitfield_body.fields, bf)
                    self.proto_fields.append({
                        'var_name': bf_var,
                        'field_name': bf.name,
                        'field_path': f"{field_path}.{bf.name}",
                        'definition': f"local {bf_var} = ProtoField.uint8(\"{proto_name}.{field_path}.{bf.name}\", \"{bf.name}\", base.DEC, nil, {mask})",
                        'size': 1,
                        'type': 'bitfield',
                        'parent_field': field.name,
                        'parent_path': field_path,
                    })
            else:
                self.proto_fields.append({
                    'var_name': var_name,
                    'field_name': field.name,
                    'field_path': field_path,
                    'definition': f"local {var_name} = ProtoField.uint8(\"{proto_name}.{field_path}\", \"{field.name}\", base.HEX)",
                    'size': 1,
                    'type': 'int',
                })

        elif isinstance(field_type, EnumTypeRef):
            enum_def = self.coco.get_enum(field_type.enum_name)
            if enum_def:
                size = self._enum_size(enum_def)
                lua_type = f"ProtoField.uint{size * 8}"
                self.proto_fields.append({
                    'var_name': var_name,
                    'field_name': field.name,
                    'field_path': field_path,
                    'definition': f"local {var_name} = {lua_type}(\"{proto_name}.{field_path}\", \"{field.name}\", base.DEC, {enum_def.name}_values)",
                    'size': size,
                    'type': 'enum',
                    'enum_name': enum_def.name,
                })
            else:
                # Embedded message - collect its fields recursively
                embedded_msg = self.coco.get_message(field_type.enum_name)
                if embedded_msg:
                    embedded_fields = self._resolve_fields(embedded_msg)
                    self._collect_proto_fields(proto_name, embedded_fields, f"{field_path}.")
                    self.proto_fields.append({
                        'var_name': var_name,
                        'field_name': field.name,
                        'field_path': field_path,
                        'definition': f"-- {var_name}: embedded message {field_type.enum_name}",
                        'type': 'message',
                        'message_name': field_type.enum_name,
                        'skip_registration': True,
                    })

    def _int_type_to_lua(self, int_type: IntegerType, field: Field = None) -> tuple[str, str]:
        """Convert integer type to Lua ProtoField type and base."""
        type_map = {
            'u8': 'ProtoField.uint8',
            'u16': 'ProtoField.uint16',
            'u32': 'ProtoField.uint32',
            'u64': 'ProtoField.uint64',
            'i8': 'ProtoField.int8',
            'i16': 'ProtoField.int16',
            'i32': 'ProtoField.int32',
            'i64': 'ProtoField.int64',
        }
        lua_type = type_map.get(int_type.base, 'ProtoField.uint8')
        base = "base.DEC"

        # Check for display formatter
        if field and field.attributes and field.attributes.display:
            fmt = field.attributes.display.name
            if fmt == "hex":
                base = "base.HEX"
            elif fmt == "ipv4":
                return ("ProtoField.ipv4", "nil")
            elif fmt == "port":
                base = "base.DEC"

        return (lua_type, base)

    def _enum_size(self, enum_def: EnumDef) -> int:
        """Get byte size of enum."""
        type_sizes = {'u8': 1, 'i8': 1, 'u16': 2, 'i16': 2, 'u32': 4, 'i32': 4, 'u64': 8, 'i64': 8}
        return type_sizes.get(enum_def.base_type, 1)

    def _calculate_bitmask(self, bitfields: list, target) -> str:
        """Calculate bitmask for a bitfield member."""
        offset = 0
        for bf in bitfields:
            if bf.name == target.name:
                mask = ((1 << bf.bit_count) - 1) << (8 - offset - bf.bit_count)
                return f"0x{mask:02X}"
            offset += bf.bit_count
        return "0xFF"

    def _size_to_lua(self, size, context_prefix: str = "") -> str:
        """Convert size spec to Lua expression."""
        if isinstance(size, LiteralSize):
            return str(size.value)
        elif isinstance(size, FieldRefSize):
            # Use the last component of the path as the Lua variable name
            # (e.g., ["header", "total_length"] -> "total_length")
            return size.field_path[-1]
        elif isinstance(size, SizeExpr):
            left = self._size_to_lua(size.left, context_prefix)
            right = self._size_to_lua(size.right, context_prefix)
            return f"({left} {size.op} {right})"
        elif isinstance(size, VariableSize):
            return "nil"
        return "nil"

    def _generate_dissector(self, msg: Message, proto_var: str):
        """Generate dissector function."""
        self._emit(f"function {proto_var}.dissector(buffer, pinfo, tree)")
        self.indent += 1

        self._emit(f"pinfo.cols.protocol = \"{msg.name}\"")
        self._emit("")
        self._emit(f"local subtree = tree:add({proto_var}, buffer(), \"{msg.name}\")")
        self._emit("local offset = 0")
        self._emit("")

        # Generate field parsing
        fields = self._resolve_fields(msg)
        self._generate_field_parsing(fields, "subtree", "", msg.name)

        self.indent -= 1
        self._emit("end")

    def _generate_field_parsing(self, fields: list[Field], tree_var: str, prefix: str, proto_name: str):
        """Generate parsing code for fields."""
        processed_bitfields = set()

        for field in fields:
            field_path = f"{prefix}{field.name}" if prefix else field.name
            var_name = f"f_{proto_name}_{field_path}".replace(".", "_")
            field_type = field.type

            if isinstance(field_type, IntegerType):
                size = field_type.byte_size
                # Check for ipv4 display
                is_ipv4 = field.attributes and field.attributes.display and field.attributes.display.name == "ipv4"
                if is_ipv4:
                    self._emit(f"local {field.name} = buffer(offset, {size}):ipv4()")
                else:
                    self._emit(f"local {field.name} = buffer(offset, {size}):uint()")
                self._emit(f"{tree_var}:add({var_name}, buffer(offset, {size}))")
                self._emit(f"offset = offset + {size}")
                self._emit("")

            elif isinstance(field_type, BytesType):
                size_expr = self._size_to_lua(field.size) if field.size else "nil"

                if size_expr == "nil":
                    self._emit(f"local {field.name}_buf = buffer(offset)")
                    self._emit(f"local {field.name}_tree = {tree_var}:add({var_name}, {field.name}_buf)")
                else:
                    self._emit(f"local {field.name}_len = {size_expr}")
                    self._emit(f"local {field.name}_buf = buffer(offset, {field.name}_len)")
                    self._emit(f"local {field.name}_tree = {tree_var}:add({var_name}, {field.name}_buf)")
                    self._emit(f"offset = offset + {field.name}_len")

                # Handle match clause
                if field.match_clause:
                    self._generate_match_parsing(field.match_clause, f"{field.name}_buf", f"{field.name}_tree", f"{field_path}.", proto_name)
                # Handle structure body
                elif field.structure_body:
                    self._emit(f"local {field.name}_offset = 0")
                    self._generate_structure_parsing(field.structure_body, f"{field.name}_tree", f"{field.name}_buf", f"{field.name}_offset", f"{field_path}.", proto_name)

                self._emit("")

            elif isinstance(field_type, StringType):
                size_expr = self._size_to_lua(field.size) if field.size else "nil"
                if size_expr == "nil":
                    self._emit(f"{tree_var}:add({var_name}, buffer(offset))")
                else:
                    self._emit(f"{tree_var}:add({var_name}, buffer(offset, {size_expr}))")
                    self._emit(f"offset = offset + {size_expr}")
                self._emit("")

            elif isinstance(field_type, BitFieldType):
                if field_path not in processed_bitfields:
                    processed_bitfields.add(field_path)
                    if field.bitfield_body:
                        self._emit(f"-- Bitfield: {field.name}")
                        for bf in field.bitfield_body.fields:
                            bf_var = f"f_{proto_name}_{field_path}_{bf.name}".replace(".", "_")
                            self._emit(f"{tree_var}:add({bf_var}, buffer(offset, 1))")
                        # Extract values for later use
                        bit_offset = 0
                        for bf in field.bitfield_body.fields:
                            mask = ((1 << bf.bit_count) - 1) << (8 - bit_offset - bf.bit_count)
                            shift = 8 - bit_offset - bf.bit_count
                            self._emit(f"local {bf.name} = bit.band(bit.rshift(buffer(offset, 1):uint(), {shift}), {(1 << bf.bit_count) - 1})")
                            bit_offset += bf.bit_count
                        self._emit("offset = offset + 1")
                    else:
                        self._emit(f"{tree_var}:add({var_name}, buffer(offset, 1))")
                        self._emit("offset = offset + 1")
                    self._emit("")

            elif isinstance(field_type, EnumTypeRef):
                enum_def = self.coco.get_enum(field_type.enum_name)
                if enum_def:
                    size = self._enum_size(enum_def)
                    self._emit(f"local {field.name} = buffer(offset, {size}):uint()")
                    self._emit(f"{tree_var}:add({var_name}, buffer(offset, {size}))")
                    self._emit(f"offset = offset + {size}")
                    self._emit("")
                else:
                    # Embedded message - expand inline
                    embedded_msg = self.coco.get_message(field_type.enum_name)
                    if embedded_msg:
                        self._emit(f"-- Embedded: {field.name} ({field_type.enum_name})")
                        self._emit(f"local {field.name}_start = offset")
                        self._emit(f"local {field.name}_tree = {tree_var}:add(buffer(offset), \"{field.name}\")")
                        embedded_fields = self._resolve_fields(embedded_msg)
                        self._generate_field_parsing(embedded_fields, f"{field.name}_tree", f"{field_path}.", proto_name)
                        self._emit(f"{field.name}_tree:set_len(offset - {field.name}_start)")
                        self._emit("")

    def _generate_structure_parsing(self, fields: list[Field], tree_var: str, buf_var: str, offset_var: str, prefix: str, proto_name: str):
        """Generate parsing for a structure body using a sub-buffer."""
        for field in fields:
            field_path = f"{prefix}{field.name}"
            var_name = f"f_{proto_name}_{field_path}".replace(".", "_")
            field_type = field.type

            if isinstance(field_type, IntegerType):
                size = field_type.byte_size
                self._emit(f"local {field.name} = {buf_var}({offset_var}, {size}):uint()")
                self._emit(f"{tree_var}:add({var_name}, {buf_var}({offset_var}, {size}))")
                self._emit(f"{offset_var} = {offset_var} + {size}")

            elif isinstance(field_type, EnumTypeRef):
                enum_def = self.coco.get_enum(field_type.enum_name)
                if enum_def:
                    size = self._enum_size(enum_def)
                    self._emit(f"local {field.name} = {buf_var}({offset_var}, {size}):uint()")
                    self._emit(f"{tree_var}:add({var_name}, {buf_var}({offset_var}, {size}))")
                    self._emit(f"{offset_var} = {offset_var} + {size}")
                else:
                    # Embedded message
                    embedded_msg = self.coco.get_message(field_type.enum_name)
                    if embedded_msg:
                        self._emit(f"local {field.name}_tree = {tree_var}:add({buf_var}({offset_var}), \"{field.name}\")")
                        embedded_fields = self._resolve_fields(embedded_msg)
                        self._generate_structure_parsing(embedded_fields, f"{field.name}_tree", buf_var, offset_var, f"{field_path}.", proto_name)

            elif isinstance(field_type, BytesType):
                size_expr = self._size_to_lua(field.size) if field.size else "nil"
                if size_expr == "nil":
                    self._emit(f"{tree_var}:add({var_name}, {buf_var}({offset_var}))")
                else:
                    self._emit(f"local {field.name}_len = {size_expr}")
                    self._emit(f"{tree_var}:add({var_name}, {buf_var}({offset_var}, {field.name}_len))")
                    self._emit(f"{offset_var} = {offset_var} + {field.name}_len")

            elif isinstance(field_type, BitFieldType):
                if field.bitfield_body:
                    for bf in field.bitfield_body.fields:
                        bf_var = f"f_{proto_name}_{field_path}_{bf.name}".replace(".", "_")
                        self._emit(f"{tree_var}:add({bf_var}, {buf_var}({offset_var}, 1))")
                    self._emit(f"{offset_var} = {offset_var} + 1")

    def _generate_match_parsing(self, match_clause: MatchClause, buf_var: str, tree_var: str, prefix: str, proto_name: str):
        """Generate if/elseif dispatch for match clause with full parsing."""
        # Use the last component of the path as the Lua variable name
        # (e.g., "header.protocol" -> "protocol" since that's how it was defined)
        discriminator = match_clause.discriminator.split(".")[-1]
        self._emit("")
        self._emit(f"-- Match on {match_clause.discriminator}")
        self._emit(f"local {prefix.replace('.', '_')}offset = 0")

        first = True
        for branch in match_clause.branches:
            if branch.pattern is None:
                self._emit("else")
                self.indent += 1
                self._emit("-- Default: raw bytes")
                self.indent -= 1
            else:
                pattern = self._pattern_to_lua(branch.pattern)
                if first:
                    self._emit(f"if {discriminator} == {pattern} then")
                    first = False
                else:
                    self._emit(f"elseif {discriminator} == {pattern} then")

                self.indent += 1
                if branch.fields:
                    offset_var = f"{prefix.replace('.', '_')}offset"
                    self._generate_structure_parsing(branch.fields, tree_var, buf_var, offset_var, prefix, proto_name)
                self.indent -= 1

        self._emit("end")

    def _pattern_to_lua(self, pattern) -> str:
        """Convert match pattern to Lua expression."""
        if isinstance(pattern, int):
            return str(pattern)
        elif isinstance(pattern, EnumValue):
            enum_def = self.coco.get_enum(pattern.enum_name)
            if enum_def:
                member = enum_def.get_member_by_name(pattern.member_name)
                if member:
                    return str(member.value)
            return f"0 --[[{pattern.enum_name}.{pattern.member_name}]]"
        return str(pattern)

    def _generate_registration(self, msg: Message, proto_var: str):
        """Generate dissector registration code."""
        self._emit("")
        self._emit("-- Registration")

        if 'ethernet' in msg.name.lower():
            self._emit("-- To register with Ethernet:")
            self._emit("-- local eth_table = DissectorTable.get(\"wtap_encap\")")
            self._emit(f"-- eth_table:add(wtap_encaps.ETHERNET, {proto_var})")
        elif 'ipv4' in msg.name.lower() or 'ip' in msg.name.lower():
            self._emit("-- To register with IP:")
            self._emit("-- local ip_table = DissectorTable.get(\"ip.proto\")")
            self._emit(f"-- ip_table:add(6, {proto_var})  -- TCP")

        self._emit(f"-- Or use: Analyze -> Decode As -> {msg.name}")
