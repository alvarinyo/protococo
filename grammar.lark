// Protococo DSL Grammar v1.0
// Parser: Lark (Python)

start: header_section include_section? definitions

// === Header Section ===
header_section: version_decl endian_decl

version_decl: "version" VERSION_NUMBER
endian_decl: "endian" ENDIAN

VERSION_NUMBER: /\d+\.\d+/
ENDIAN: "le" | "be"

// === Include Section ===
include_section: include_decl+
include_decl: "include" STRING

// === Definitions ===
definitions: definition*

definition: const_def
          | enum_def
          | message_def

// === Constants ===
const_def: "const" IDENT "=" const_value

const_value: HEX_NUMBER
           | DEC_NUMBER
           | BIN_NUMBER
           | STRING

// === Enums ===
enum_def: "enum" IDENT ":" base_type "{" enum_members "}"

enum_members: enum_member ("," enum_member)* ","?

enum_member: IDENT "=" (HEX_NUMBER | DEC_NUMBER)

// === Messages ===
message_def: LAYER_KW? "message" IDENT extends_clause? "{" message_body "}"

extends_clause: "extends" IDENT

message_body: message_item*

message_item: field_def
            | override_def

// === Fields ===
// Fields always have a type followed by a name
field_def: integer_type endian_suffix? IDENT default_value? match_clause? attributes?  -> int_field
         | BYTES_KW IDENT size_spec? default_value? match_clause? attributes?  -> bytes_field
         | STRING_KW string_encoding? IDENT size_spec? default_value? match_clause? attributes?  -> string_field
         | PAD_KW size_spec? default_value? attributes?  -> pad_field
         | bitfield_type IDENT bitfield_body? match_clause? attributes?  -> bitfield
         | IDENT IDENT size_spec? default_value? match_clause? attributes?  -> typed_field

bitfield_body: "{" bitfield_member+ "}"
bitfield_member: BIT_KW IDENT
               | BITS_KW "[" DEC_NUMBER "]" IDENT

integer_type: INT_TYPE

endian_suffix: ":" ENDIAN

string_encoding: ":" "cstr"

bitfield_type: "bits" "[" DEC_NUMBER "]"

size_spec: "[" size_value "]"

size_value: size_expr       // expression (includes simple values)
          | GREEDY_SIZE     // greedy size [...] - consumes all remaining
          | "fill_to" ":" DEC_NUMBER  -> fill_to_size  // fill to minimum size [fill_to: N]
          | "until" ":" value_expr  -> until_size  // terminator-based size [until: 0x00]
          |                 // empty = variable length (or branch-determined with match)

GREEDY_SIZE.2: "..."  // Higher priority than operators

// Size expressions with arithmetic
?size_expr: size_term
          | size_expr "+" size_term  -> size_add
          | size_expr "-" size_term  -> size_sub

?size_term: size_factor
          | size_term "*" size_factor  -> size_mul

?size_factor: DEC_NUMBER     // literal: 8
            | field_ref      // field reference: length or header.total_length
            | "(" size_expr ")"

field_ref: IDENT ("." IDENT)*

default_value: "=" value_expr

value_expr: HEX_NUMBER
          | DEC_NUMBER
          | BIN_NUMBER
          | STRING
          | enum_value
          | IDENT            // constant reference

enum_value: IDENT "." IDENT

// === Overrides (in child messages) ===
override_def: field_path "=" value_expr           // value override
            | field_path "{" message_body "}"     // structure override

field_path: IDENT ("." IDENT)*

// === Pattern Matching ===
match_clause: "match" field_ref "{" match_branches "}"

match_branches: match_branch+

match_branch: match_pattern "->" match_body

match_body: "{" message_body "}"     // full form: { field1; field2 }
          | field_def                // shorthand: single field without braces

match_pattern: HEX_NUMBER
             | DEC_NUMBER
             | BIN_NUMBER
             | enum_value
             | "_"          // default case

// === Bitfield Body ===
// When field_type is bits[N], the field can have a bitfield_body
// This is handled specially in the transformer

// === Field Attributes ===
attributes: "[" attribute ("," attribute)* "]"

attribute: "display" ":" display_format
         | "doc" ":" STRING

display_format: IDENT

// === Base Types (for enum declarations) ===
base_type: INT_TYPE

// === Terminals ===
// Keywords must be defined before IDENT to take priority
INT_TYPE.2: "u8" | "u16" | "u32" | "u64" | "i8" | "i16" | "i32" | "i64"
BYTES_KW.2: "bytes"
STRING_KW.2: "string"
PAD_KW.2: "pad"
BIT_KW.2: "bit"
BITS_KW.2: "bits"
LAYER_KW.2: "layer"

IDENT: /[a-zA-Z_][a-zA-Z0-9_]*/
HEX_NUMBER: /0x[0-9a-fA-F]+/
DEC_NUMBER: /[0-9]+/
BIN_NUMBER: /0b[01]+/
STRING: /"[^"]*"/

// === Comments and Whitespace ===
COMMENT: /\/\/[^\n]*/
BLOCK_COMMENT: /\/\*[\s\S]*?\*\//

%import common.WS
%ignore WS
%ignore COMMENT
%ignore BLOCK_COMMENT
